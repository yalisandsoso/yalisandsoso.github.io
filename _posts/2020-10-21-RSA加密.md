---
bg: "tools.jpg"
layout: post
title:  RSA加密
crawlertitle: 信息安全
summary: 安全
date:   2020-10-21
categories: 加密
tags: ['Gengzi 10']
author: hekun
bg: "african-penguins.jpg"
---

 RSA数学原理以及底层算法实现。

## Overview

```mathematica
什么是RSA加密？ Rivest–Shamir–Adleman 居然是个些人名...

呃，

RSA是从古老的加解密慢慢发展出来的一种非对称加密解密方式
古典的加解密需要传递私钥，也就是公钥加密后，需要私钥进行解密，这就相当不安全

那么RSA能够做到什么呢？
公钥加密，私钥解密
私钥加密，公钥解密
也就是不再需要传递私钥。

工程上，我们常常采用RSA加密一个对称密钥，再利用密钥加密信息。
```

### Theory

公钥&私钥

```mathematica
1. 互质大数 p & q, 计算p、q乘积n
    取 p = 7 及 q = 9, 所以n = 63
2. 计算n的欧拉函数fi(n),即n的质因子的个数为48个
    fi(n) = n*(1-1/p)*(1-1/q) = 63*(1-1/7)*(1-1/9) = 48
3. 选择一个数e，使得e与fi(n)互质
工程上，要求1 < e < fi(n)
选择e = 5
    由费马小定理:
       a,n互质，那么：(a^fi(n) - 1)mod(n) = 0
    所以：
       (e^fi[fi(n)] - 1)mod(fi(n)) = 0
4. 根据模反定理，a、n是互质正整数，可以找到一个正整数b, (ab - 1)mod(n) = 0
        a = e
        n = fi(n)
        d = b
        (e*d - 1)mod(fi(n)) = 0
        由费马定理知道，d = e^{fi[fi(n)]-1}
计算e相对fi(n)的模反元素：
        d = e^{fi[fi(n)]-1}
        d = 5^{fi(48)-1} = 5^15 = 30,517,578,125
/***********************************************************************************************************************************************************
换一个方式计算d:
	(e*d - 1) mod(fi(n)) = 0
	=> e*d = k*fi(n) + 1
	=> e*d - k*fi(n) = 1
	=> 令 x = d, y = -k
	   e*x + fi(n)*y = 1
根据扩展欧几里得算法，这个方程有解的充分必要条件是e和fi(n)互质
通过欧几里得算法迭代求得
       d = x = -19
   d 加减fi(n)的倍数都是有效的值，d' = d + 48 = 29 
*****************************************************************************/

5. 得到密钥
公钥[n,e] = [63,5]
密钥[n,d] = [63,29]
```



欧几里得算法与扩展

```mathematica
欧几里得算法，又称辗转相除法，用于求a,b得最大公约数
Greatest Common Divisor
gcd(a,b)=gcd(b, a mod b)
设 a>b,r=a mod b, r不为0
   若a = k*b + r
   => r = a mod b
  1.1 设d是a,b得一个公约数，记d|a, d|b，即a,b都可以被d整除
而 r = a - k*b, 
	==> r/d = a/d - k*b/d = m   (右边可以确定为整数)
	==> d|r
所以, d是 b, (a mod b)的公约数
  1.2 设d是b, a mod b的公约数
  => d|b, d|(a-k*b), k是一个整数
  => d|a 
     d也是 a,b的公约数
 
  所以 (a,b)和(b, a mod b)的公约数一样，最大公约数也一样
  
/***********************************************************************************************************************************************************
扩展欧几里得算法，求解不定方程 a*x + b*y = m
	设a,b不全为0，则存在x,y, 
	s.t.
	   gcd(a,b) = x*a + y*b
	如果，a,b互质，那么gcd(a,b) = 1
证明：
    1. b == 0:
    	=> gcd(a,b) = a, 此时 x = 1, y = 0
    2. a*b!=0:
      设 x1*a + y1*b = gcd(a,b), x2*b + y2*(a%b) = gcd(b,a%b)
      因为:
          gcd(a,b) == gcd(b,a%b)
      =>
          x1*a + y1*b = x2*b + y2*(a%b)                ....  (a%b) == 0 时
                      = x2*b + (a - (a/b)*b)*y2
      =>
          x1*a + y1*b = y2*a + (-y2*(a/b) + x2)*b
      => 
          x1 = y2 
          y1 = x2 - y2* (a/b)

*****************************************************************************/
```



加密&解密

```mathematica
加密公式, 计算c
     ((m^e - c) mod n) = 0

设公钥为[63,5], 假设消息是m = 10
n = 63, m = 10, e = 5

((10^5 - c) mod 63) = 0

=> c = 19  (余数)

10^5 / 63 = k ... r
c = r = 19

解密公式，计算m
     (((c^d - m)) mod n) = 0
我们的私钥是[63,29]
d = 29, n = 63
=>  19^29 / 63 = k....10
m = 10                                ---- 使用蒙哥马利算法 Montgomery
```



解密证明

```mathematica
(c^d - m) (mod n) = 0
c 密文 d私钥 m明文 n

复杂，待解决
```



安全性级别

```mathematica
公钥[n,e]
私钥[n,d]
由于n,e都是公开的，那么安全性由d的可推导难易程度决定
	1. (e*d - 1) mod (fi(n)) = 0, 需要知道d，那么需要知道e和fi(n)   ....扩展欧几里德
	2. e是公开的，所以只需要知道fi(n)
	3. fi(n) = (p - 1)*(q - 1), 计算fi(n)需要对正数n进行质数分解

取决于整数n的质数分解的难度!
加密的消息 m 必须要小于 n
```



模运算

```
    (a + b)%p = (a%p + b%p)%p
    (a - b)%p = (a%p - b%p + p)%p
    (a^b)%p = ((a%p)^b)%p
```



(a^b%k)

```C++
Montgomery 蒙哥马利幂模算法

    (a * b)%p = (a%p * b%p)%p

    用于简便a mod M、a*b mod M、a^b mod M的运算, 不用计算除法的计算模的方法
    
    公式：
       C' = A * B * R^(-1) mod M
    R = 2^(M位)
    R^(-1)相当于M的模逆：  R*R^(-1) mod M = 1; 这个条件成立的充要条件是R与M互素
    因此，只要求M为奇数即可（可见Montgomery适用于对奇数求模）.

S 被除数
M 除数
q 累加M的次数
R 记作2^bitlen, bitlen为归0的个数
余数：  （S+qM）/R
   
    S 和 (S+qM)同余。 
    扯到这儿，我懵逼了。暂停扯淡。
    
    
==============================================================================
	需要使用的公式进行模幂转化为模乘:
		(a * b)%n = (a%n * b%n)%n
        (a + b)%n = (a%n + b%n)%n
==============================================================================
   
    我们的问题： C = A^B (mod) n
    转化为模乘问题: C' = A * B mod (n)
    利用一个思想"平方-乘降幂法"，说句不好听的，就是把幂次方以"降幂"化成乘积形式
例如:  a^9 % n
    => (a^8 * a)% n
    => (a^8%n * a%n)%n
   
    a^8%n
    => (a^4%n * a^4%n)%n
    
    a^4%n
    => (a^2%n * a^2%n)%n
    
    a^2%n
    => (a%n * a%n)%n
    
    a%n
    => (1 * a)%n
    => (1%n * a%n)%n = (a%n)%n
   
    接下来使用Montgomery模乘对模乘运算进行优化，化解不必要的除法
    ====================================================
    基本思想:
       选取R = 2^k, k满足 n < 2^k
       因为R > n, R是2的整数次幂，n是素数，R和n互素  
       由欧拉方程有解条件
           :   存在 0 < R^(-1) < n
                   0 < n'     < R
               满足： R*R^-1 - n*n' = 1
       此时，将C' = A*B (mod n) 转化为 C' = A'*B'*R^-1 (mod n)    .... (待)数学证明
               其中 A' = A * R(mod n)
                   B' = B * R(mod n)
    ======================================================
    又卡bug
```



解疑

```c++
1. 是否所有的整数都有质因子？
    17是质数，无法再进行质因子分解
   
2. 二进制除法(二补数法) ？
   二补数: 求反 + 1
100011 / 000101

100011 - 000101 -> 011110 + 111011 = 1011001 → 011001 (商 1+1=10)
011001 + 111011 = 1010100 → 010100 (商 10+1=11)
010100 + 111011 = 1001111 → 001111 (11+1=100)
001111 + 111011 = 1001010 → 001010 (100+1=101)
001010 + 111011 = 10000101 → 0000101 (101+1=110)
0000101 + 111011 = 1000000 → 000000 (110+1=111)
       
3. 模幂运算 ？
3333^5555 mod(10)

       a^b%p = ((a%p)^b)%p
       =>  ((3333%10)^5555)%10
       =>  3^5555 (%10) 
       
       (a*b)%p = (a%p * b%p)%p
       =>  5555 = 4 * 1388 + 3
       => 3^5555 (%10) = (3^(4*1388) * 3^3) (%10)
       => (3^(4*1388) (%10) * 3^3 (%10)) (%10)           .... 3^4 (%10) = 1
       => (1 * 7) (%10) = 7
       
   X^N(%P): 初始化 Res = 1
            Res *= X
            Res %= P              ..... N次
   
   优化:
         N为偶数  X^N = (X*X)^[N/2]
         N为奇数  X^N = X*X^(N-1) = X * (X*X)^[N/2]
```



快速幂模算法

```matlab
a^b %c
-> b = b0 + b1*(2) + b2*(2^2) + ... + bn*(2^n)      ... 二进制

a^(b0 + b1*(2) + b2*(2^2) + ... + bn*(2^n))
-> a^b0 * a^[b1*(2)] * a^[b2*(2^2)] * ... * a^[bn*(2^n)]
->
  {a^b0 %c *
   a^[b1*(2)] %c * 
   a^[b2*(2^2)] %c *
   ... *
   a^[bn*(2^n)] %c} %c
由于b的二进制位不是0就是1，忽略bx为0的项
=> A1 = (a^[bx*(2^x)] %c)
   A2 = (a^[by*(2^y)] %c)
   ...
   Am = (a^[bn*(2^n)] %c)
   
a^b %c ==>
  (A1 * A2 ...* Am) %c 
%%
%%  1. A1,A2...Am与b的二进制位有关
  
 a = (a*a) % c
 
 1. a*a == a^2
 2. a^2*a^2 == a^4
 3. a^4*a^4 == a^8
thus,a->a^2->a^4->a^8.... 指数正好是2^i
```



## Codes

GCD

```c++
/*
1997 / 615 = 3 (余 152)
615 / 152 = 4(余7)
152 / 7 = 21(余5)
7 / 5 = 1 (余2)
5 / 2 = 2 (余1)
2 / 1 = 2 (余0)

long long gcd(long long a,long long b){
    return b?gcd(b,a%b):a;
}

*/

int gcd(int a, int b)
{
    if (a < b) swap(a, b);
    return b == 0 ? a : gcd(b, a % b);
}
```



扩展GCD

```c++
int exgcd(int a,int b,int &x,int &y)
{
    if(b==0)
    {
        x=1,y=0;
        return a;
    }
    int d=exgcd(b,a%b,x,y);
    int k=x;
    x=y;
    y=k-a/b*y;
    return d;
}
```



快速幂模运算(Montgomery方法还有许多疑惑，暂不实现)

```c++
/*
int fast_pow(int a,int b,int c)
{
    int ans=1;   ///记录结果
    a=a%c;   ///预处理，使得a处于c的数据范围之下
    while(b!=0)
    {
        if(b&1)///奇数
        {
            ans=(ans*a)%c;///消除指数为奇数的影响
        }
        b>>=1;    ///二进制的移位操作,不断的遍历b的二进制位
        a=(a*a)%c;   ///不断的加倍
    }
    return ans;
}
*/
long powermod(long a, long n, long m)
{
	long res = 1L;
	while (n) {
		if (n & 1L) { 
			res *= a;
			res %= m;
		}
		a *= a;
		a %= m;
		n >>= 1;
	}
	return res;
}
```



### Other Support

RSA原理与实现： https://cjting.me/2020/03/13/rsa/

扩展GCD：https://www.cnblogs.com/fusiwei/p/11775503.html

模运算: [https://baike.baidu.com/item/%E6%A8%A1%E8%BF%90%E7%AE%97](https://baike.baidu.com/item/模运算)

Montgomery:[http://zwgeek.com/2016/09/29/%E8%92%99%E5%93%A5%E9%A9%AC%E5%88%A9%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/](http://zwgeek.com/2016/09/29/蒙哥马利算法详解/)

二进制除法:[https://zh.wikihow.com/%E5%81%9A%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0%E7%9A%84%E9%99%A4%E6%B3%95%E8%BF%90%E7%AE%97](https://zh.wikihow.com/做二进制数的除法运算)

Montgomery乘法:https://blog.csdn.net/BjarneCpp/article/details/77644958

快速幂模算法：https://www.cnblogs.com/wkfvawl/p/9125224.html

对称加密: https://www.jianshu.com/p/f86e33f29338